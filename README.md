# cs221hw6
  VIEW THIS IN RAW FORMAT
  to build the project, use make. to run the tests, use valgrind ./test_htree and valgrind ./test_hforest. the latter won't print anything.
  htree was a pretty close port of tree from last week, including the private helper function value_found. didn't define setters for htree. we had to include getters, and if you are including getters and setters its a sign that the variable should be public. used get_child(HTree::Direction::LEFT) instead of left_ despite it being far uglier since the prompt wants us to use getters. test_htree was similarly a port of test_tree, although it didn't test node_at since implementing it was not in the spec.
  for hforest.hh, the constructor takes a vector of tree pointers. if provided nothing, it has a default value of an empty vector. this covers all the ways i can think of using a forest of read-only trees. the copy constructor, i suppose, but if that were to be implemented it would just be the default version. the construction is explicit because cpplint wants it to be. destructor arguably should not be specified since the only variable is a vector of shared pointers. (as a result the destructor does nothing).
  for hforest.cc i used the standard make_heap. it is the more proper thing to do and is probably easier. only notable thing here is that i made it re-heap when the forest is initialized or adds/removes elements. if i didn't do this the structure might not be a heap when the customer needs it to be. with any luck the folks who made make_heap made it run quickly in the case that the input is almost a valid heap already (e.g. after pop_tree() is called). for test_hforest.cc i made three big trees. the first was the tree used in testing htree, while the second and third were this tree with all the 1s replaced by 2s and 3s respectively. it's a bit ugly. testing the validity of the heap was hard so i just made sure that the first tree had the highest value and then made sure that it was still valid since that was more simple copy-paste. similarly for deletion i made sure that the element deleted was always the one with the highest value and that the size went down each time. then i tested some edge cases and wrapped up.